{"name":"快速开发微信公众平台框架---简介","tagline":"Using this framework, you can quickly develop a WeiXin public platform, the framework USE the. Net 3.5 development, support. Net 3.5 above ","body":"年底了，比较忙，大家都在展望未来，对于30+的我来说，发展和稳定是个难以取舍的问题。最近发了些求职信，鸟无音讯，没事做，做点帮助大家的东西吧。\r\n\r\n之前做了个微信公众平台的查询系统，在开发中，发觉了一些微信公众平台的接口问题《对微信公众平台开发的消息处理》，开发起来比较痛苦，对于微信过来的消息，需要解析后一个一个来返回，编写之痛苦，相信有人明白。在开发中，一直考虑着如何来简化开发，暂时想不到好的模式来开发，就自己胡乱写了一个，希望对大家有帮助。\r\n\r\n    代码已发布到github：https://github.com/JamesYing/JCWX\r\n\r\n第一步：创建Model类库，我把微信发送来的消息，事件、返回回去的消息，都写成了Demo\r\n\r\nRequestMessage:微信发送过来的消息、事件。此类是个虚类，继承自WXMessage。\r\n\r\nResponseMessage:返回给微信服务器端的消息，同样也是虚类，继承自WXMessage。\r\n\r\n在《对微信公众平台开发的消息处理》中，已经知道，微信服务器端通过Post方式，发来一段xml，通过Request.InputStream获取，是个Stream类型，之前一直考虑着，用XmlSerializer.Deserialize(stream)来解析成对象，但在实践当中，发觉无法判断MsgType，我必须先判断再解析，从性能上来说不太合适，所以我又重写了RequestMessage的构造函数，RequestMessage(XElement)，把Stream –> XElement，就可以构造RequestMessage(要使用.net framework 3.5以上版本，您也可以自己修改成适合3.5以下版本)。不过我还是保留了原先的Deserialize方式，使用方法：RequestMessage.Deserializ<RequestMessage>(stream)，具体可以参考我的源代码。\r\n\r\n我们知道返回给用户的也是一个Xml信息，您可以直接使用ResponseMessage.Serializable()返回给用户xml文档。ResponseMessage的构造函数中，有一个ResponseMessage(RequestMessage message)，这是为了把FromUserName, ToUserName转换一下，后续文章会继续讲解。\r\n\r\n第二步：创建了Business类库，提供一些公开接口，方便大家来进行开发。\r\n\r\nIMessageRole:信息处理规则，规则的具体实现，请继承此接口\r\n\r\nIMessageHandler:信息处理，根据信息，反馈给用户。\r\n\r\nNotHandlerMessage：继承自IMessageHandler，这是一个在无法处理情况下，返回一个null的实现，您也可以自己来写。\r\n\r\nIMessageRole接口中，只有一个IMessageHandler MessageRole(XElement xml);方法，为了提高性能，我把过来的Stream转换成了XElement，通过xml.Element(“MsgType”)进行类型判断，返回一个IMessageHandler。\r\n\r\nIMEssageHandler:ResponseMessage HandlerRequestMessage(XElement xml);根据不同的Request返回给用户不同的ResponseMessage。\r\n\r\n这个快速框架就这些，很简单，实践的话，需要自己编写：\r\n\r\n1、信息处理规则，继承IMessageRole，在处理中，您可以根据MsgType进行分析，也可以根据不同Text内容进行分析，返回不同IMessageHanlder就可以了。\r\n\r\n2、信息处理，继承IMessageHandler，这个可能要写很多个，看你的项目要求了。\r\n\r\n微信公众平台提供了测试接口，但暂时我还没有用，就简单自己模拟了下。\r\n\r\n创建一个RequestTextMessage（文本信息）:\r\n\r\nvar request = new RequestTextMessage { ToUserName = \"sh_bus\", FromUserName = \"jamesying1\", MsgId = 123123123L, CreateTime = 1231231322L, Content = \"my request message\" };\r\n\r\n折叠代码\r\n\r\n模拟成Stream:\r\n\r\nStringWriter sw = new StringWriter(); var xmlSerializer = new XmlSerializer(typeof(RequestTextMessage)); var ns = new XmlSerializerNamespaces(); ns.Add(\"\", \"\"); xmlSerializer.Serialize(sw, request, ns); Console.WriteLine(sw.ToString()); Stream stream = new MemoryStream(sw.Encoding.GetBytes(sw.ToString()));\r\n\r\n折叠代码\r\n\r\n好了，有了模拟环境，我们，我们写一个自己的规则：\r\n\r\npublic class MyMessageRole : IMessageRole { public IMessageHandler MessageRole(XElement xml) { try { MsgType msgType = (MsgType)Enum.Parse(typeof(MsgType), xml.Element(\"MsgType\").Value, true); return MessageHandlerByMsgType(msgType); } catch { return new NotHandlerMessage(); } } private IMessageHandler MessageHandlerByMsgType(MsgType msgType) { IMessageHandler messageHandler = null; switch (msgType) { case MsgType.Text: messageHandler = new TextMessageHander(); break; case MsgType.Event: messageHandler = new EventMessageHandler(); break; default: messageHandler = new NotHandlerMessage(); break; } return messageHandler; } }\r\n\r\n折叠代码\r\n\r\n再编写2个消息处理类：\r\n\r\npublic class TextMessageHandler : IMessageHandler { public ResponseMessage HandlerRequestMessage(XElement xml) { var request = new RequestTextMessage(xml); if (request.Content.IndexOf(\"info\") > -1) { return new ResponseTextMessage(request) { Content = \"this message has keyword:info\" }; } else { return new ResponseTextMessage(request) { Content = \"this message has not keyword\" }; } } }\r\n\r\n折叠代码\r\n\r\nTextMessageHandler中，处理的类型为文本信息，判断内容中含有info，返回一个ResponseTextMessage。下面我们实践下：\r\n\r\nvar reader = XmlReader.Create(stream); var doc = XDocument.Load(reader); var xml = doc.Element(\"xml\"); IMessageRole role = new MyMessageRole(); IMessageHandler handler = role.MessageRole(xml); ResponseMessage response = handler.HandlerRequestMessage(xml); if (response != null) { Console.WriteLine(response.Serializable()); } else { Console.WriteLine(\"not handler\"); }\r\n\r\n折叠代码\r\n\r\n请加入response的判断，检查是否为空，因为我们不是每条消息都必须处理的。\r\n\r\n看下运行结果：\r\n\r\nimage\r\n\r\nok，运行成功，目前还未进行测试，后续会加入测试代码，相信有了这个快速开发框架，会给大家开发微信公众平台有更好的帮助。好了，下班了，明天继续说明一些Model。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}